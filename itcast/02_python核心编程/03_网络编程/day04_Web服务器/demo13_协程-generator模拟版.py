# 生产者-消费者模型 ~ 生成器函数版(几乎1:1仿协程)
def consumer():
    while True:
        line = yield '生成器方法被调用, 返回expression_list给调用者'
        if line is not None:
            print(f'消费: {line}')


def producer(c):
    f = open('D:\workspace\备忘.txt', 'r+', encoding='UTF8')
    # yield_ret_value = c.send(None) # 启动generator    生成器迭代器方法首次被调用, 生成器函数开始执行, 执行到yield暂停, 并返回expression_list到调用者, 并设置yield表达式的值为None
    # 1.send():
    #   1.恢复生成器函数执行, 并发送参数值到生成器函数;
    #   2.若要使用send()方法启动generator, 其参数必须是None, 因为没有yield表达式接收参数值
    # 2.__next__(): 启动或恢复生成器函数执行
    #   1.当使用该方法恢复生成器函数执行, 当前yield表达式的值总是evaluates to None, 然后继续执行到下一个yield表达式, 该生成器再次被暂停, 并返回expression_list到该方法的调用者
    #   2.该方法通常通过for迭代/内置函数next()被隐式调用
    yield_ret_value = c.__next__()    # 启动generator
    print(f'辅助学习yield执行过程, 与本例协程生产消费模型无关{yield_ret_value:->150}')
    while True:
        line = f.readline()    # Text I/O readline()方法到达EOF时返回空串
        if line == '':
            break
        print(f'生产: {line}')
        yield_ret_value = c.send(line)    # 恢复生成器函数执行, 并设置yield表达式的值为line
        print(f'辅助学习yield执行过程, 与本例协程生产消费模型无关{yield_ret_value:->150}')


if __name__ == '__main__':
    c = consumer()  # 返回一个生成器迭代器对象
    producer(c)


# 一.协程Coroutine 参考: https://www.liaoxuefeng.com/wiki/001374738-215095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000
#   1.又称微线程
#   2.该概念很早就被提出, 直到近些年才在某些语言中应用(golang, Lua等) ~ python通过yield提供了支持(唯一不同: 控制权问题), 第三方库有完整实现
#   3.子程序(函数)在所有语言中都是层级调用 ~ 通过栈实现
#     1.线程也是子程序
#     2.调用顺序明确: 一个入口, 返回
#   4.协程和子程序类似, 但其调用不同
#     1.执行过程中内部可中断, 去执行其他协程, 适当时机继续执行 ~ 在单线程中实现多线程效果
#       1.协程中断不是子程序中的函数调用, 而是类似于CPU中断
#     2.特点
#       1.高效: 协程切换由程序员手动调度, 没有像进/线程切换的开销
#       2.无锁机制: 单线程, 不存在竞争状态, 共享资源无需加锁, 只需判断其状态即可 ~ 高效 ~ 这个无锁是指单线程下无锁
#   5.多核利用
#     1.多进/线程+协程 == 充分利用多核 + 充分发挥协程高性能 == 吊炸天性能
#   6.应用
#     1.传统生产者-消费者模型用多线程/进程通过锁机制控制队列实现, 很容易死锁
#     2.协程实现: 生产/消费者协程在适当时机通过yield切换, 效率极高

# 相关知识
# 一.https://studygolang.com/articles/4535
#   1.进程: 拥有独立的堆/栈, 由操作系统调度
#   2.线程:    独立栈和共享堆, 由操作系统调度 ~ 标准线程
#   3.协程:    独立栈和共享堆, 代码调度
#     1.特点
#       1.轻量级: 协程执行只需要分配极少栈存(4~5KB), 线程1~8MB
#       2.高性能: 避免无意义调度, 高性能, 但必须由程序员手动调度
#       3.综合1+2 = 适合大规模并发服务(eg.go语言)
#   4.Note
#     1.进程: 资源分配基本单位
#     2.线程: CPU调度基本单位
#     3.类比不同语言内存管理
#       1.进程/线程切换由操作系统调度 ~ GC语
#       2.协程由程序员手动调度 ~ 非GC语言
#


# <====yield表达式翻译====>
# 1.当一个生成器函数被调用, 返回一个被称为生成器的迭代器 ~ 生成器迭代器
# 2.然后该生成器控制该生成器函数的执行
# 3.当该生成器的某个方法被调用, 生成器函数开始执行
# 4.同时, 执行到第一个yield表达式时, 再次暂停执行, 返回expression_list的值到调用者
# 5.通过暂停, 我们的意思是所有局部状态被保留, 包括局部变量的当前绑定, 指令指针, 内部评估栈, 任何异常处理状态
# 6.当通过调用该生成器的一个方法来恢复生成器函数的执行, 该函数可以被准确地恢复, 好像yield表达式是一个外部调用
# 7.生成器函数恢复执行后, yield表达式的值取决于恢复生成器函数执行所调用的函数
# 8.如果__next__()方法被调用(通常是通过for迭代或内置函数next())yield表达式的值是None
# 9.另一方面, 如果send()方法被调用, yield表达式的值是send()方法的实参参数值
#
# 1.所有这些使得生成器函数和协程非常相似; 他们yield多次, 他们有多个入口点, 且他们的执行可以被暂停
# 2.唯一的不同是生成器函数不能控制yields后应该从哪继续执行; 控制权总是被转移到生成器的调用者
#
# 1.在try结构中的任意位置都允许yield表达式
# 2.如果生成器被销毁前没有被恢复(通过达到零引用计数或通过被垃圾回收), 生成器迭代器的close()方法会被调用, 允许后续的finally子句执行
#
# 1.当使用yield from <expr>时, 会把提供的表达式当做子迭代器处理
# 2.子迭代器生成的所有值, 将会被直接传递给当前生成器的方法调用者
# 3.如果生成器由适当的方法, 任何通过send()传入的值和通过throw()传入的异常, 将被传递给底层的迭代器
# 4.否则, send()将会raise AttributeError或TypeError, throw()会立刻raise传入的异常
#
# 1.当底层的迭代器完成, raised StopIteration示例对象的value属性变成yield表达式的值
# 2.可以是当raising StopIteration时显式设置或当子迭代器是生成器(通过从子生成器返回一个值)时自动设置
#
# Changed in version 3.3: 添加yield from <expr> 以委派控制流给子迭代器
#
# 当yield表达式是赋值语句右边唯一的表达式时, 括号可省略













































