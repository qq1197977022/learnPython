from multiprocessing import Pool
import os
import time

if os is not None:
    print(f'{os.getpid():->60}')


def worker(cur_num):
    print(f'{cur_num}--->pid = {os.getpid()}--->ppid={os.getppid()}')
    time.sleep(1)


print(f'+++++++++{os.getpid()}')
if __name__ == '__main__':
    print(f'---------{os.getpid()}')
    pol = Pool(3)    # 创建一个带有3个进程的进程池
    for i in range(10):
        # pol.apply(worker, (i,))    # 添加任务到进程池 ~ 阻塞
        pol.apply_async(worker, (i,))    # 添加任务到进程池 ~ 非阻塞
    pol.close()
    pol.join()

    print(f'*********{os.getpid()}')

print(f'========={os.getpid()}')


'''
    1.在下述两行打断点
        pol = Pool(3)
        for i in range(10):

        --------------------------------------------------------5832
        +++++++++5832
        ---------5832
        <注>: 程序从上往下解释执行, 主进程输出上述内容
        --------------------------------------------------------7584
        +++++++++7584
        =========7584
        --------------------------------------------------------2540
        +++++++++2540
        =========2540
        -------------------------------------------------------10548
        +++++++++10548
        =========10548
        <注>: 主进程执行到pol = Pol(3)
              1.创建包含3个子进程的进程池, 三个子进程分别包含当前源码一份副本, 从上往下解释执行分别输出上述内容
              2.因为在各子进程中if __name__ == '__main__': 不成立, 所以if语句体内语句只在主进程中执行
        0--->pid = 7584--->ppid=5832
        1--->pid = 2540--->ppid=5832
        2--->pid = 10548--->ppid=5832
        3--->pid = 7584--->ppid=5832
        4--->pid = 2540--->ppid=5832
        5--->pid = 10548--->ppid=5832
        6--->pid = 7584--->ppid=5832
        7--->pid = 2540--->ppid=5832
        8--->pid = 10548--->ppid=5832
        9--->pid = 7584--->ppid=5832
        <注>: 主进程执行到for i in range(10):
              分别在各子进程上调用worker方法, 输出上述内容
        *********5832
        =========5832
        <注>: 主进程继续执行, 输出上述内容
        
    2.Note.
        1.使用进程池Pool和使用Process类创建子进程特性一致
            1.各子进程分别拥有当前源码一份副本
            2.子进程中if __name__ == '__main__': 不成立, 所以if语句体内语句只在主进程中执行
        2.使用fork函数创建子进程
            1.以fork调用处为分界点, 之前代码只有主进程有, 之后代码各子进程均由一份副本
            2.子进程中if __name__ == '__main__': 成立
            
'''

# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

'''
    --------------------------------------------------------5832   :   主进程5832
    +++++++++5832
    ---------5832
    --------------------------------------------------------7584    :   子进程7583
    +++++++++7584
    =========7584
    --------------------------------------------------------2540    :   子进程2540
    +++++++++2540
    =========2540
    -------------------------------------------------------10548    :   子进程10548
    +++++++++10548
    =========10548
    0--->pid = 7584--->ppid=5832                                    :   子进程7584
    1--->pid = 2540--->ppid=5832                                    :   子进程2540
    2--->pid = 10548--->ppid=5832                                   :   子进程10548
    3--->pid = 7584--->ppid=5832
    4--->pid = 2540--->ppid=5832
    5--->pid = 10548--->ppid=5832
    6--->pid = 7584--->ppid=5832
    7--->pid = 2540--->ppid=5832
    8--->pid = 10548--->ppid=5832
    9--->pid = 7584--->ppid=5832
    *********5832                                                   :   主进程5832
    =========5832
'''

'''Linux平台输出 .....也是醉了....说好的跨平台呢?
    --------------------------------------------------------4837
    +++++++++4837
    ---------4837
    0--->pid = 4838--->ppid=4837
    1--->pid = 4839--->ppid=4837
    2--->pid = 4840--->ppid=4837
    3--->pid = 4838--->ppid=4837
    4--->pid = 4839--->ppid=4837
    5--->pid = 4839--->ppid=4837
    6--->pid = 4838--->ppid=4837
    7--->pid = 4839--->ppid=4837
    8--->pid = 4839--->ppid=4837
    9--->pid = 4840--->ppid=4837
    *********4837
    =========4837
'''



















































